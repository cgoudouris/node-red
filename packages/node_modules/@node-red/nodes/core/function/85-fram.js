/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

module.exports = function(RED) {
    "use strict";

    // FRAM Interpretation Profiles based on FMV standards
    const INTERPRETATION_PROFILES = {
        technological: {
            name: "Technological",
            focus: "technical_systems",
            aspects: {
                input: { weight: 0.25, precision: "high", timing: "precise" },
                output: { weight: 0.25, precision: "high", timing: "precise" },
                preconditions: { weight: 0.15, precision: "medium", timing: "precise" },
                resources: { weight: 0.20, precision: "high", timing: "flexible" },
                time: { weight: 0.10, precision: "high", timing: "critical" },
                control: { weight: 0.05, precision: "medium", timing: "flexible" }
            },
            variabilityFactors: ["system_load", "processing_capability", "interface_quality"],
            ontologyDomain: "technical_domain"
        },
        human: {
            name: "Human",
            focus: "human_factors",
            aspects: {
                input: { weight: 0.20, precision: "medium", timing: "flexible" },
                output: { weight: 0.20, precision: "medium", timing: "flexible" },
                preconditions: { weight: 0.25, precision: "medium", timing: "flexible" },
                resources: { weight: 0.15, precision: "low", timing: "flexible" },
                time: { weight: 0.05, precision: "low", timing: "very_flexible" },
                control: { weight: 0.15, precision: "high", timing: "flexible" }
            },
            variabilityFactors: ["cognitive_load", "experience_level", "fatigue", "situational_awareness"],
            ontologyDomain: "human_domain"
        },
        organizational: {
            name: "Organizational",
            focus: "organizational_processes",
            aspects: {
                input: { weight: 0.15, precision: "low", timing: "flexible" },
                output: { weight: 0.20, precision: "medium", timing: "flexible" },
                preconditions: { weight: 0.30, precision: "high", timing: "flexible" },
                resources: { weight: 0.25, precision: "medium", timing: "flexible" },
                time: { weight: 0.05, precision: "low", timing: "very_flexible" },
                control: { weight: 0.05, precision: "high", timing: "flexible" }
            },
            variabilityFactors: ["policy_compliance", "resource_availability", "communication_quality", "hierarchical_constraints"],
            ontologyDomain: "organizational_domain"
        }
    };

    function FRAMNode(n) {
        RED.nodes.createNode(this, n);
        
        this.name = n.name;
        this.functionName = n.functionName || "FRAM Function";
        this.variabilityMode = n.variabilityMode || "normal";
        this.enableResonance = n.enableResonance || false;
        this.timeConstraint = n.timeConstraint || "";
        this.resourceThreshold = n.resourceThreshold || 100;
        
        // Advanced FMV-compatible configuration
        this.interpretationProfile = n.interpretationProfile || "technological";
        this.enableMetadata = n.enableMetadata || false;
        this.hierarchicalGroup = n.hierarchicalGroup || "";
        this.ontologyMapping = n.ontologyMapping || {};
        this.standardizedReporting = n.standardizedReporting || false;
        this.advancedAnalysis = n.advancedAnalysis || false;
        
        var node = this;
        
        // Get current interpretation profile
        this.profile = INTERPRETATION_PROFILES[this.interpretationProfile] || INTERPRETATION_PROFILES.technological;
        
        // Advanced FRAM state tracking with metadata support
        this.framState = {
            input: null,
            preconditions: null,
            resources: null,
            time: null,
            control: null,
            output: null,
            lastExecution: null,
            variability: 0,
            metadata: {},
            performanceIndicators: {
                timing: "on-time",
                precision: "precise", 
                efficiency: "efficient"
            },
            ontologyData: {},
            hierarchicalContext: {},
            analysisResults: {}
        };
        
        // Input handlers for each FRAM aspect with advanced processing
        this.on("input", function(msg, send, done) {
            send = send || function() { node.send.apply(node, arguments); };
            done = done || function() {};
            
            try {
                // Determine which FRAM aspect this input represents
                var aspect = msg.framAspect || detectAspect(msg);
                
                // Process metadata if enabled
                if (node.enableMetadata && msg.metadata) {
                    processMetadata(msg.metadata, aspect);
                }
                
                // Update FRAM state with profile-aware processing
                node.framState[aspect] = {
                    value: msg.payload,
                    timestamp: Date.now(),
                    topic: msg.topic || aspect,
                    variability: calculateVariabilityWithProfile(msg.payload, aspect),
                    metadata: msg.metadata || {},
                    profileWeight: node.profile.aspects[aspect] ? node.profile.aspects[aspect].weight : 0.1,
                    qualityIndicators: assessQualityIndicators(msg.payload, aspect)
                };
                
                // Perform ontology mapping if configured
                if (node.ontologyMapping && node.ontologyMapping[aspect]) {
                    performOntologyMapping(aspect, msg.payload);
                }
                
                // Check if all required aspects are available for execution
                if (canExecuteFunction()) {
                    executeFramFunction(send, done);
                } else {
                    // Not ready to execute, just update state
                    updateNodeStatus();
                    done();
                }
                
            } catch (err) {
                node.error("FRAM processing error: " + err.message, msg);
                done(err);
            }
        });
        
        function detectAspect(msg) {
            // Enhanced aspect detection with profile-specific keywords
            if (msg.topic) {
                var topic = msg.topic.toLowerCase();
                
                // Profile-specific detection patterns
                if (node.interpretationProfile === "technological") {
                    if (topic.includes("sensor") || topic.includes("signal") || topic.includes("data_input")) return "input";
                    if (topic.includes("system_state") || topic.includes("hardware_ready")) return "preconditions";
                    if (topic.includes("processing_power") || topic.includes("bandwidth")) return "resources";
                    if (topic.includes("cycle_time") || topic.includes("latency")) return "time";
                    if (topic.includes("system_control") || topic.includes("automation")) return "control";
                } else if (node.interpretationProfile === "human") {
                    if (topic.includes("user_input") || topic.includes("operator_action")) return "input";
                    if (topic.includes("training_complete") || topic.includes("authorized")) return "preconditions";
                    if (topic.includes("cognitive_capacity") || topic.includes("workload")) return "resources";
                    if (topic.includes("response_time") || topic.includes("availability")) return "time";
                    if (topic.includes("supervision") || topic.includes("guidance")) return "control";
                } else if (node.interpretationProfile === "organizational") {
                    if (topic.includes("policy_input") || topic.includes("directive")) return "input";
                    if (topic.includes("approval") || topic.includes("compliance")) return "preconditions";
                    if (topic.includes("budget") || topic.includes("personnel")) return "resources";
                    if (topic.includes("deadline") || topic.includes("schedule")) return "time";
                    if (topic.includes("oversight") || topic.includes("governance")) return "control";
                }
                
                // Generic patterns
                if (topic.includes("input") || topic.includes("trigger")) return "input";
                if (topic.includes("precondition") || topic.includes("condition")) return "preconditions";
                if (topic.includes("resource") || topic.includes("material")) return "resources";
                if (topic.includes("time") || topic.includes("timing")) return "time";
                if (topic.includes("control") || topic.includes("supervision")) return "control";
            }
            
            // Default to input if not specified
            return "input";
        }
        
        function processMetadata(metadata, aspect) {
            // FMV-compatible metadata processing
            if (!node.framState.metadata[aspect]) {
                node.framState.metadata[aspect] = {};
            }
            
            // Store metadata according to FMV standards
            node.framState.metadata[aspect] = {
                ...node.framState.metadata[aspect],
                ...metadata,
                profile: node.interpretationProfile,
                timestamp: Date.now(),
                hierarchicalGroup: node.hierarchicalGroup
            };
            
            // Process hierarchical grouping metadata
            if (metadata.hierarchicalGroup) {
                node.framState.hierarchicalContext[aspect] = {
                    group: metadata.hierarchicalGroup,
                    level: metadata.hierarchicalLevel || 0,
                    parent: metadata.parentFunction || null
                };
            }
        }
        
        function assessQualityIndicators(value, aspect) {
            // Assess quality based on interpretation profile
            var aspectConfig = node.profile.aspects[aspect];
            if (!aspectConfig) return { precision: "unknown", timing: "unknown", completeness: "unknown" };
            
            var indicators = {
                precision: aspectConfig.precision,
                timing: aspectConfig.timing,
                completeness: value !== null && value !== undefined ? "complete" : "incomplete",
                reliability: "high" // Default, could be enhanced with actual assessment
            };
            
            // Profile-specific quality assessment
            switch (node.interpretationProfile) {
                case "technological":
                    indicators.reliability = typeof value === "number" ? "high" : "medium";
                    break;
                case "human":
                    indicators.reliability = "medium"; // Human factors inherently more variable
                    break;
                case "organizational":
                    indicators.reliability = value && typeof value === "object" ? "high" : "medium";
                    break;
            }
            
            return indicators;
        }
        
        function performOntologyMapping(aspect, value) {
            // Map FRAM aspects to ontological concepts
            var mapping = node.ontologyMapping[aspect];
            if (mapping) {
                node.framState.ontologyData[aspect] = {
                    concept: mapping.concept || aspect,
                    domain: node.profile.ontologyDomain,
                    value: value,
                    semanticType: mapping.semanticType || "functional_aspect",
                    timestamp: Date.now()
                };
            }
        }
        
        function calculateVariabilityWithProfile(value, aspect) {
            // Enhanced variability calculation using interpretation profile
            var baseVariability = calculateBaseVariability(value, aspect);
            var profileFactor = getProfileVariabilityFactor(aspect);
            
            // Apply profile-specific variability factors
            var profileVariability = baseVariability * profileFactor;
            
            // Consider interpretation profile variability factors
            var additionalFactors = node.profile.variabilityFactors || [];
            var factorModifier = 1.0;
            
            additionalFactors.forEach(function(factor) {
                // Simulate different variability factors
                switch (factor) {
                    case "system_load":
                        factorModifier *= (0.8 + Math.random() * 0.4); // 0.8 to 1.2
                        break;
                    case "cognitive_load":
                        factorModifier *= (0.6 + Math.random() * 0.8); // 0.6 to 1.4
                        break;
                    case "policy_compliance":
                        factorModifier *= (0.9 + Math.random() * 0.2); // 0.9 to 1.1
                        break;
                    default:
                        factorModifier *= (0.85 + Math.random() * 0.3); // 0.85 to 1.15
                }
            });
            
            return Math.min(profileVariability * factorModifier, 1.0);
        }
        
        function calculateBaseVariability(value, aspect) {
            // Base FRAM variability calculation
            var baseVariability = 0;
            
            switch (aspect) {
                case "time":
                    baseVariability = Math.abs((Date.now() % 1000) - 500) / 500;
                    break;
                case "resources":
                    if (typeof value === "number") {
                        baseVariability = Math.abs(value - node.resourceThreshold) / node.resourceThreshold;
                    }
                    break;
                case "preconditions":
                    baseVariability = value ? 0.1 : 0.8;
                    break;
                default:
                    baseVariability = Math.random() * 0.3;
            }
            
            // Apply variability mode modifier
            switch (node.variabilityMode) {
                case "low":
                    return baseVariability * 0.5;
                case "high":
                    return baseVariability * 2.0;
                default:
                    return baseVariability;
            }
        }
        
        function getProfileVariabilityFactor(aspect) {
            // Get variability factor based on interpretation profile
            var aspectConfig = node.profile.aspects[aspect];
            if (!aspectConfig) return 1.0;
            
            // Convert precision and timing to variability factors
            var precisionFactor = 1.0;
            var timingFactor = 1.0;
            
            switch (aspectConfig.precision) {
                case "high": precisionFactor = 0.7; break;
                case "medium": precisionFactor = 1.0; break;
                case "low": precisionFactor = 1.4; break;
            }
            
            switch (aspectConfig.timing) {
                case "critical": timingFactor = 0.6; break;
                case "precise": timingFactor = 0.8; break;
                case "flexible": timingFactor = 1.2; break;
                case "very_flexible": timingFactor = 1.5; break;
            }
            
            return (precisionFactor + timingFactor) / 2;
        }
        
        function canExecuteFunction() {
            // Enhanced execution readiness check based on interpretation profile
            var hasInput = node.framState.input !== null;
            var hasPreconditions = node.framState.preconditions === null || node.framState.preconditions.value;
            
            // Profile-specific execution requirements
            switch (node.interpretationProfile) {
                case "technological":
                    // Technological systems require input and resources
                    return hasInput && node.framState.resources !== null;
                case "human":
                    // Human factors require input and preconditions (authorization, training)
                    return hasInput && hasPreconditions;
                case "organizational":
                    // Organizational processes require preconditions and resources
                    return hasPreconditions && node.framState.resources !== null;
                default:
                    return hasInput && hasPreconditions;
            }
        }
        
        function executeFramFunction(send, done) {
            try {
                // Calculate overall function variability with profile weighting
                var overallVariability = calculateWeightedVariability();
                
                // Determine performance characteristics using profile-specific analysis
                var performance = determineProfileBasedPerformance(overallVariability);
                
                // Check for functional resonance if enabled
                var resonance = node.enableResonance ? checkAdvancedFunctionalResonance() : null;
                
                // Perform advanced analysis if enabled
                var advancedAnalysis = node.advancedAnalysis ? performAdvancedAnalysis() : null;
                
                // Generate standardized report if enabled
                var standardReport = node.standardizedReporting ? generateStandardReport(overallVariability, performance) : null;
                
                // Process function with profile-specific logic
                var processResult = processProfileSpecificFunction();
                
                // Generate comprehensive FRAM output
                var output = {
                    payload: {
                        functionName: node.functionName,
                        interpretationProfile: node.interpretationProfile,
                        result: processResult,
                        variability: {
                            overall: overallVariability,
                            aspectSpecific: getAspectSpecificVariabilities(),
                            profileFactors: node.profile.variabilityFactors
                        },
                        performance: performance,
                        resonance: resonance,
                        advancedAnalysis: advancedAnalysis,
                        standardReport: standardReport,
                        framAspects: {
                            input: node.framState.input,
                            preconditions: node.framState.preconditions,
                            resources: node.framState.resources,
                            time: node.framState.time,
                            control: node.framState.control,
                            output: processResult
                        },
                        metadata: node.enableMetadata ? node.framState.metadata : null,
                        ontologyData: node.framState.ontologyData,
                        hierarchicalContext: node.framState.hierarchicalContext,
                        executionTime: Date.now(),
                        profileWeights: node.profile.aspects
                    },
                    topic: node.functionName + "_output",
                    framOutput: true,
                    interpretationProfile: node.interpretationProfile
                };
                
                // Store output in state for potential resonance analysis
                node.framState.output = processResult;
                node.framState.lastExecution = Date.now();
                
                // Send output
                send(output);
                updateNodeStatus("executed");
                done();
                
            } catch (err) {
                node.error("FRAM function execution error: " + err.message);
                done(err);
            }
        }
        
        function calculateWeightedVariability() {
            // Calculate variability using profile-specific weights
            var weightedSum = 0;
            var totalWeight = 0;
            
            Object.keys(node.profile.aspects).forEach(function(aspect) {
                if (node.framState[aspect] && node.framState[aspect].variability !== undefined) {
                    var weight = node.profile.aspects[aspect].weight;
                    weightedSum += node.framState[aspect].variability * weight;
                    totalWeight += weight;
                }
            });
            
            return totalWeight > 0 ? weightedSum / totalWeight : 0;
        }
        
        function getAspectSpecificVariabilities() {
            var variabilities = {};
            
            Object.keys(node.framState).forEach(function(aspect) {
                if (node.framState[aspect] && node.framState[aspect].variability !== undefined) {
                    variabilities[aspect] = {
                        value: node.framState[aspect].variability,
                        weight: node.profile.aspects[aspect] ? node.profile.aspects[aspect].weight : 0,
                        qualityIndicators: node.framState[aspect].qualityIndicators || {}
                    };
                }
            });
            
            return variabilities;
        }
        
        function determineProfileBasedPerformance(variability) {
            // Enhanced performance determination based on interpretation profile
            var basePerformance = determineBasePerformance(variability);
            
            // Profile-specific performance adjustments
            switch (node.interpretationProfile) {
                case "technological":
                    // Technological systems have stricter timing requirements
                    if (variability > 0.3) basePerformance.timing = "degraded";
                    if (variability > 0.5) basePerformance.precision = "imprecise";
                    break;
                case "human":
                    // Human factors allow more timing flexibility but affect precision
                    if (variability > 0.4) basePerformance.precision = "variable";
                    if (variability > 0.7) basePerformance.timing = "delayed";
                    break;
                case "organizational":
                    // Organizational processes prioritize compliance over speed
                    if (variability > 0.6) basePerformance.efficiency = "bureaucratic";
                    if (variability > 0.8) basePerformance.timing = "delayed";
                    break;
            }
            
            // Add profile-specific metrics
            basePerformance.profileCompliance = variability < 0.4 ? "high" : variability < 0.7 ? "medium" : "low";
            basePerformance.interpretationProfile = node.interpretationProfile;
            
            return basePerformance;
        }
        
        function determineBasePerformance(variability) {
            // Base FRAM performance determination
            var timing = variability < 0.2 ? "on-time" : variability < 0.5 ? "early/late" : "too-early/too-late";
            var precision = variability < 0.3 ? "precise" : variability < 0.6 ? "imprecise" : "approximate";
            var efficiency = variability < 0.25 ? "efficient" : variability < 0.55 ? "inefficient" : "acceptable";
            
            return { 
                timing: timing, 
                precision: precision, 
                efficiency: efficiency, 
                overallVariability: variability 
            };
        }
        
        function checkAdvancedFunctionalResonance() {
            // Advanced functional resonance detection using profile-specific patterns
            var resonanceData = {
                detected: false,
                intensity: 0,
                type: "normal",
                timestamp: Date.now(),
                profileSpecific: {},
                propagationPotential: "low"
            };
            
            var overallVar = calculateWeightedVariability();
            resonanceData.intensity = overallVar;
            
            // Profile-specific resonance patterns
            switch (node.interpretationProfile) {
                case "technological":
                    // Technical systems: resonance from cascading failures
                    if (overallVar > 0.6 && node.framState.resources && node.framState.resources.variability > 0.5) {
                        resonanceData.detected = true;
                        resonanceData.type = "cascading_failure";
                        resonanceData.propagationPotential = "high";
                    }
                    break;
                case "human":
                    // Human factors: resonance from cognitive overload
                    if (overallVar > 0.5 && node.framState.control && node.framState.control.variability > 0.4) {
                        resonanceData.detected = true;
                        resonanceData.type = "cognitive_overload";
                        resonanceData.propagationPotential = "medium";
                    }
                    break;
                case "organizational":
                    // Organizational: resonance from policy conflicts
                    if (overallVar > 0.7 && node.framState.preconditions && node.framState.preconditions.variability > 0.6) {
                        resonanceData.detected = true;
                        resonanceData.type = "policy_conflict";
                        resonanceData.propagationPotential = "medium";
                    }
                    break;
            }
            
            // General resonance detection
            if (overallVar > 0.8) {
                resonanceData.detected = true;
                resonanceData.type = "general_amplification";
                resonanceData.propagationPotential = "high";
            }
            
            return resonanceData;
        }
        
        function performAdvancedAnalysis() {
            // Comprehensive FRAM analysis based on current state and profile
            var analysis = {
                profileCompliance: assessProfileCompliance(),
                aspectCoverage: assessAspectCoverage(),
                variabilityPatterns: analyzeVariabilityPatterns(),
                riskAssessment: performRiskAssessment(),
                recommendations: generateRecommendations(),
                timestamp: Date.now()
            };
            
            return analysis;
        }
        
        function assessProfileCompliance() {
            // Assess how well the function execution aligns with the interpretation profile
            var compliance = {
                overall: "compliant",
                aspectCompliance: {},
                deviations: []
            };
            
            Object.keys(node.profile.aspects).forEach(function(aspect) {
                if (node.framState[aspect]) {
                    var expectedWeight = node.profile.aspects[aspect].weight;
                    var actualVariability = node.framState[aspect].variability;
                    var qualityIndicators = node.framState[aspect].qualityIndicators;
                    
                    var aspectCompliance = "compliant";
                    if (actualVariability > expectedWeight * 2) {
                        aspectCompliance = "non-compliant";
                        compliance.deviations.push({
                            aspect: aspect,
                            issue: "high_variability",
                            expected: expectedWeight,
                            actual: actualVariability
                        });
                    }
                    
                    compliance.aspectCompliance[aspect] = {
                        status: aspectCompliance,
                        variability: actualVariability,
                        quality: qualityIndicators
                    };
                }
            });
            
            // Overall compliance assessment
            var deviationCount = compliance.deviations.length;
            if (deviationCount > 2) {
                compliance.overall = "non-compliant";
            } else if (deviationCount > 0) {
                compliance.overall = "partially-compliant";
            }
            
            return compliance;
        }
        
        function assessAspectCoverage() {
            // Assess which FRAM aspects are covered and their quality
            var coverage = {
                totalAspects: 6,
                coveredAspects: 0,
                aspectStatus: {},
                completeness: 0
            };
            
            ["input", "output", "preconditions", "resources", "time", "control"].forEach(function(aspect) {
                if (node.framState[aspect] !== null) {
                    coverage.coveredAspects++;
                    coverage.aspectStatus[aspect] = {
                        present: true,
                        quality: node.framState[aspect].qualityIndicators || {},
                        metadata: node.framState[aspect].metadata || {}
                    };
                } else {
                    coverage.aspectStatus[aspect] = {
                        present: false,
                        required: node.profile.aspects[aspect] ? node.profile.aspects[aspect].weight > 0.15 : false
                    };
                }
            });
            
            coverage.completeness = coverage.coveredAspects / coverage.totalAspects;
            
            return coverage;
        }
        
        function analyzeVariabilityPatterns() {
            // Analyze variability patterns across aspects
            var patterns = {
                dominant: null,
                trend: "stable",
                correlations: {},
                anomalies: []
            };
            
            var variabilities = [];
            var aspectNames = [];
            
            Object.keys(node.framState).forEach(function(aspect) {
                if (node.framState[aspect] && node.framState[aspect].variability !== undefined) {
                    variabilities.push(node.framState[aspect].variability);
                    aspectNames.push(aspect);
                }
            });
            
            if (variabilities.length > 0) {
                // Find dominant variability source
                var maxVar = Math.max(...variabilities);
                var maxIndex = variabilities.indexOf(maxVar);
                patterns.dominant = {
                    aspect: aspectNames[maxIndex],
                    variability: maxVar,
                    weight: node.profile.aspects[aspectNames[maxIndex]] ? node.profile.aspects[aspectNames[maxIndex]].weight : 0
                };
                
                // Detect anomalies
                var avgVar = variabilities.reduce((sum, v) => sum + v, 0) / variabilities.length;
                variabilities.forEach(function(v, i) {
                    if (v > avgVar * 1.5) {
                        patterns.anomalies.push({
                            aspect: aspectNames[i],
                            variability: v,
                            deviation: v - avgVar
                        });
                    }
                });
                
                // Determine trend
                if (maxVar > avgVar * 1.3) {
                    patterns.trend = "increasing";
                } else if (maxVar < avgVar * 0.7) {
                    patterns.trend = "decreasing";
                }
            }
            
            return patterns;
        }
        
        function performRiskAssessment() {
            // Assess risks based on current variability and profile
            var assessment = {
                overallRisk: "low",
                riskFactors: [],
                criticalAspects: [],
                mitigationSuggestions: []
            };
            
            var overallVar = calculateWeightedVariability();
            
            // Risk level determination
            if (overallVar > 0.7) {
                assessment.overallRisk = "high";
                assessment.riskFactors.push("high_overall_variability");
            } else if (overallVar > 0.4) {
                assessment.overallRisk = "medium";
                assessment.riskFactors.push("moderate_variability");
            }
            
            // Profile-specific risk assessment
            switch (node.interpretationProfile) {
                case "technological":
                    if (node.framState.resources && node.framState.resources.variability > 0.5) {
                        assessment.criticalAspects.push("resources");
                        assessment.mitigationSuggestions.push("Implement resource monitoring and load balancing");
                    }
                    break;
                case "human":
                    if (node.framState.control && node.framState.control.variability > 0.4) {
                        assessment.criticalAspects.push("control");
                        assessment.mitigationSuggestions.push("Provide additional training and decision support");
                    }
                    break;
                case "organizational":
                    if (node.framState.preconditions && node.framState.preconditions.variability > 0.6) {
                        assessment.criticalAspects.push("preconditions");
                        assessment.mitigationSuggestions.push("Review and clarify policies and procedures");
                    }
                    break;
            }
            
            return assessment;
        }
        
        function generateRecommendations() {
            // Generate actionable recommendations based on analysis
            var recommendations = [];
            
            var overallVar = calculateWeightedVariability();
            var coverage = assessAspectCoverage();
            
            // Coverage recommendations
            if (coverage.completeness < 0.8) {
                recommendations.push({
                    type: "coverage",
                    priority: "high",
                    message: "Consider providing inputs for missing FRAM aspects to improve analysis completeness",
                    missingAspects: Object.keys(coverage.aspectStatus).filter(a => !coverage.aspectStatus[a].present)
                });
            }
            
            // Variability recommendations
            if (overallVar > 0.6) {
                recommendations.push({
                    type: "variability",
                    priority: "medium",
                    message: "High variability detected. Consider implementing control measures to reduce uncertainty",
                    affectedAspects: Object.keys(node.framState).filter(a => 
                        node.framState[a] && node.framState[a].variability > 0.5
                    )
                });
            }
            
            // Profile-specific recommendations
            switch (node.interpretationProfile) {
                case "technological":
                    if (!node.framState.time || node.framState.time.variability > 0.4) {
                        recommendations.push({
                            type: "timing",
                            priority: "high",
                            message: "Technological systems require precise timing. Consider implementing real-time monitoring"
                        });
                    }
                    break;
                case "human":
                    if (!node.framState.preconditions || node.framState.preconditions.variability > 0.5) {
                        recommendations.push({
                            type: "training",
                            priority: "medium",
                            message: "Human factor analysis shows inconsistent preconditions. Verify training and authorization status"
                        });
                    }
                    break;
                case "organizational":
                    if (!node.framState.resources || node.framState.resources.variability > 0.6) {
                        recommendations.push({
                            type: "resources",
                            priority: "medium",
                            message: "Organizational processes require stable resource allocation. Review budget and personnel assignments"
                        });
                    }
                    break;
            }
            
            return recommendations;
        }
        
        function generateStandardReport(variability, performance) {
            // Generate FMV-compatible standardized report
            var report = {
                reportType: "FRAM_Analysis_Report",
                version: "1.0",
                timestamp: new Date().toISOString(),
                functionDetails: {
                    name: node.functionName,
                    interpretationProfile: node.interpretationProfile,
                    hierarchicalGroup: node.hierarchicalGroup || "ungrouped"
                },
                executionSummary: {
                    overallVariability: variability,
                    performance: performance,
                    aspectCoverage: assessAspectCoverage().completeness,
                    profileCompliance: assessProfileCompliance().overall
                },
                aspectAnalysis: getDetailedAspectAnalysis(),
                variabilityAnalysis: {
                    profileFactors: node.profile.variabilityFactors,
                    dominantSource: analyzeVariabilityPatterns().dominant,
                    anomalies: analyzeVariabilityPatterns().anomalies
                },
                recommendations: generateRecommendations(),
                metadata: node.enableMetadata ? node.framState.metadata : null,
                ontologyMapping: node.framState.ontologyData
            };
            
            return report;
        }
        
        function getDetailedAspectAnalysis() {
            var analysis = {};
            
            Object.keys(node.profile.aspects).forEach(function(aspect) {
                analysis[aspect] = {
                    configured: node.profile.aspects[aspect],
                    actual: node.framState[aspect] ? {
                        value: node.framState[aspect].value,
                        variability: node.framState[aspect].variability,
                        quality: node.framState[aspect].qualityIndicators,
                        timestamp: node.framState[aspect].timestamp
                    } : null,
                    compliance: node.framState[aspect] ? 
                        (node.framState[aspect].variability <= node.profile.aspects[aspect].weight * 1.5 ? "compliant" : "non-compliant") : 
                        "not-provided"
                };
            });
            
            return analysis;
        }
        
        function processProfileSpecificFunction() {
            // Enhanced FRAM function processing based on interpretation profile
            var inputValue = node.framState.input ? node.framState.input.value : null;
            var resourcesValue = node.framState.resources ? node.framState.resources.value : 100;
            var controlValue = node.framState.control ? node.framState.control.value : "auto";
            var preconditionsValue = node.framState.preconditions ? node.framState.preconditions.value : true;
            
            var result = {
                processedInput: inputValue,
                interpretationProfile: node.interpretationProfile,
                profileSpecificProcessing: {},
                success: true,
                timestamp: Date.now()
            };
            
            // Profile-specific processing logic
            switch (node.interpretationProfile) {
                case "technological":
                    result.profileSpecificProcessing = {
                        systemLoad: resourcesValue,
                        processingEfficiency: Math.max(0, 100 - (calculateWeightedVariability() * 100)),
                        systemState: preconditionsValue ? "operational" : "degraded",
                        outputQuality: calculateWeightedVariability() < 0.3 ? "high" : "standard"
                    };
                    result.technicalMetrics = {
                        throughput: Math.round((100 - calculateWeightedVariability() * 50)),
                        reliability: calculateWeightedVariability() < 0.2 ? "high" : "medium",
                        latency: node.framState.time ? node.framState.time.variability * 100 : 0
                    };
                    break;
                    
                case "human":
                    result.profileSpecificProcessing = {
                        cognitiveLoad: Math.min(100, resourcesValue + (calculateWeightedVariability() * 50)),
                        decisionQuality: preconditionsValue && calculateWeightedVariability() < 0.4 ? "good" : "variable",
                        situationalAwareness: controlValue !== "auto" ? "high" : "moderate",
                        stressLevel: calculateWeightedVariability() > 0.5 ? "elevated" : "normal"
                    };
                    result.humanFactors = {
                        performanceLevel: Math.max(0, 100 - (calculateWeightedVariability() * 80)),
                        adaptability: "high", // Humans are generally adaptable
                        errorPotential: calculateWeightedVariability() > 0.6 ? "elevated" : "normal"
                    };
                    break;
                    
                case "organizational":
                    result.profileSpecificProcessing = {
                        policyCompliance: preconditionsValue ? "compliant" : "non-compliant",
                        resourceUtilization: resourcesValue,
                        processEfficiency: Math.max(0, 100 - (calculateWeightedVariability() * 60)),
                        coordinationLevel: controlValue === "supervised" ? "high" : "standard"
                    };
                    result.organizationalMetrics = {
                        bureaucraticDelay: calculateWeightedVariability() * 50,
                        stakeholderAlignment: preconditionsValue ? "aligned" : "divergent",
                        processMaturity: calculateWeightedVariability() < 0.3 ? "mature" : "developing"
                    };
                    break;
            }
            
            // Apply variability effects based on profile
            var variability = calculateWeightedVariability();
            if (variability > 0.6) {
                result.success = Math.random() > (variability * 0.8); // Profile-adjusted success probability
                result.variabilityEffects = {
                    degradation: "significant",
                    adaptationRequired: true,
                    riskLevel: "elevated"
                };
            } else if (variability > 0.3) {
                result.variabilityEffects = {
                    degradation: "minor",
                    adaptationRequired: false,
                    riskLevel: "normal"
                };
            }
            
            // Add metadata processing results if enabled
            if (node.enableMetadata) {
                result.metadataProcessing = {
                    hierarchicalLevel: node.framState.hierarchicalContext,
                    ontologyMappings: node.framState.ontologyData,
                    enrichmentLevel: Object.keys(node.framState.metadata).length > 0 ? "enriched" : "basic"
                };
            }
            
            return result;
        }
        
        function updateNodeStatus(action) {
            var statusText = "";
            var statusFill = "grey";
            var statusShape = "dot";
            
            if (action === "executed") {
                statusText = "Executed (" + node.interpretationProfile + "): " + new Date().toLocaleTimeString();
                statusFill = "green";
                statusShape = "dot";
            } else {
                var readyAspects = 0;
                var totalAspects = 6; // input, output, preconditions, resources, time, control
                var profileInfo = "";
                
                Object.keys(node.framState).forEach(function(aspect) {
                    if (["input", "preconditions", "resources", "time", "control", "output"].includes(aspect)) {
                        if (node.framState[aspect] !== null) readyAspects++;
                    }
                });
                
                // Show interpretation profile in status
                profileInfo = " [" + node.interpretationProfile.charAt(0).toUpperCase() + node.interpretationProfile.slice(1) + "]";
                
                statusText = readyAspects + "/" + totalAspects + " aspects" + profileInfo;
                
                // Color coding based on readiness and profile requirements
                if (canExecuteFunction()) {
                    statusFill = "yellow";
                    statusText = "Ready to execute" + profileInfo;
                } else if (readyAspects >= 1) {
                    statusFill = "blue";
                } else {
                    statusFill = "grey";
                }
                
                // Special shape for hexagonal FRAM node
                statusShape = "ring";
            }
            
            node.status({
                fill: statusFill,
                shape: statusShape,
                text: statusText
            });
        }
        
        // Initialize with profile-aware status
        updateNodeStatus();
        
        // Clear status on close
        this.on("close", function() {
            node.status({});
        });
    }
    
    RED.nodes.registerType("fram", FRAMNode);
};